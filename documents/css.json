{
  "name": "14. Tailwind CSS: Token Best Practices for Performance",
  "description": "Guide to avoiding inline tokens and using standard Tailwind classes to reduce CSS payload by up to 71% and improve Web Vitals.",
  "content": "---\ndescription: Learn how to performatically use tailwind css tokens.\n---\n\n## TL;DR\n\nAvoid using custom tokens like `h-[15px]` or `p-[3px]`. Opt for Tailwind tokens\nsuch as `h-8` and `p-2` instead. Also, steer clear of specifying colors in your\ntokens (e.g., `bg-[#fd429a]`). Instead, use theme colors for better\nmaintainability.\n\n## Introduction\n\nThis guide explores best practices for achieving optimal front-end performance\nwith Tailwind CSS at Deco. We'll dive into the TailwindCSS generation process,\nexamine how inline tokens impact Web Vitals metrics, and establish simple rules\nfor maintaining a high-performance score.\n\n### Understanding Tailwind CSS Build Process\n\nDeco's framework allows seamless integration of TailwindCSS tokens within any\nJSX component, applying styles without additional configuration. While this is\nconvenient for begginers, understanding the underlying process is crucial for\nperformance optimization.\n\nWhenever changes are made to your website's code, the \"Tailwind generation\"\nprocess scans all `.tsx` files in your codebase. Subsequently, it extracts CSS\ntokens, merging them into a single `styles.css` file. This file is then served\nto the browser, styling your components. This process repeats whenever code\nchanges occur.\n\nHowever, the consequence is a larger-than-necessary `styles.css` file containing\nstyles for all components, impacting performance metrics. Consider a scenario\nwith a home page (`Home.tsx`) and a product page (`Product.tsx`):\n\n```tsx\n// Home.tsx\nexport default function Home() {\n  return <div class=\"flex justify-center p-2\">Foo</div>;\n}\n\n// Product.tsx\nexport default function Product() {\n  return <div class=\"flex justify-center p-4\">Bar</div>;\n}\n```\n\nBy triggering the \"Tailwind generation\" process we get the following\n`styles.css`\n\n```css\n.flex {\n  display: flex;\n}\n\n.justify-center {\n  justify-content: center;\n}\n\n.p-2 {\n  padding: 8px;\n}\n\n.p-4 {\n  padding: 16px;\n}\n```\n\nEven though `p-4` is not used in the home page, it's included in `styles.css`,\nincreasing CSS payload and affecting Web Vitals metrics (FCP).\n\nIn the previous example, both `flex` and `justify-center` tokens are re-used. In\nbig projects, this kind of class re-utilization tends to grow. Re-usability is\nkey for having a performatic tailwind project. However inline tokens may break\nthis trend. Examples of inline tokens include `p-[3px]`, `h-[4rem]`, and\n`bg-[#fdb43a]`. These classes are unlikely to be reused loading to an increased\n`styles.css` size and hindering Core Web Vitals.\n\nTo avoid inline syntax when replicating styles, follow a simple rule of thumb:\nuse nearby tokens. For instance:\n\n- `p-[3px]` -> `p-2`\n- `h-[4rem]` -> `p-8`\n- `bg-[#fdb43a]` -> `bg-primary`\n\nThis greatly increases re-usability and improves overall website performance\n\n### Real-world Example: 71% Reduction in CSS Payload\n\nApplying these techniques to one of our projects resulted in a remarkable 71%\nreduction in the final CSS payload. This not only improved Web Vitals scores but\nalso allowed for easy theming.\n\n### Conclusion\n\nTailwind CSS is a potent tool for styling JSX components. By comprehending the\nbuild process and optimizing your codebase, you can balance flexibility and\nefficiency. Advocate for the use of pure Tailwind tokens and theme tokens,\nfostering a more maintainable and performant application.\n\nHappy coding with Tailwind CSS at Deco!\n"
}