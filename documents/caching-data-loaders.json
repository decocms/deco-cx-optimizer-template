{
  "name": "10. Loader Caching: Keys, TTL & Performance",
  "description": "Comprehensive guide to caching loaders with cache modes (stale-while-revalidate, no-store), cache key generation, TTL configuration, and best practices for reducing API latency.",
  "content": "---\ndescription: Cache your data loaders with keys and TTL to massively reduce latency and API load.\nsince: 1.0.0\n---\n\n## Why cache loaders?\n\nLoaders fetch data that powers your pages and sections. Caching them:\n\n- Reduces API latency and backend load\n- Improves consistency and resilience under spikes\n- Makes async rendering faster by serving warm data\n\n> Strong recommendation: enable caching for all read‑mostly and public data loaders. Opt out only for user‑specific or highly volatile data.\n\n## How loader caching works\n\nIn a loader module you can export two optional fields:\n\n```ts\n// Cache policy\nexport const cache =\n  // \"no-store\" | \"no-cache\" | \"stale-while-revalidate\" | { maxAge: number }\n\n// Cache key generator\nexport const cacheKey = (props, req, ctx) => string | null\n```\n\n### Cache modes\n\n- \"no-store\" (default):\n  - Disables cache for this loader and prevents dependent sections from being cached.\n  - Use for user‑specific or sensitive data (e.g., carts, sessions).\n\n- \"no-cache\":\n  - Skips cache for this loader run, but does not block dependent caches.\n  - Use when the loader must always run but the section may still be cached separately.\n\n- \"stale-while-revalidate\":\n  - Serve cached data immediately when available and revalidate in the background when stale.\n  - Best default for public/read‑mostly loaders.\n\n- { maxAge: number }:\n  - Same as \"stale-while-revalidate\" with a custom TTL (in seconds) for the loader response.\n\n### Time‑to‑live (TTL)\n\n- Default TTL when using strings (e.g., \"stale-while-revalidate\") is 60 seconds.\n- Override default with environment variable `CACHE_MAX_AGE_S`.\n- Or set per‑loader TTL via `export const cache = { maxAge: 300 }`.\n\n### Cache key\n\nThe `cacheKey(props, req, ctx)` must uniquely represent the inputs that change the response. It can return:\n\n- `string`: use as the cache key\n- `null`: disable caching for this invocation (e.g., for authenticated users)\n\nGood key inputs to include:\n\n- Props that affect data (filters, slugs, pagination)\n- Request‑scoped traits that change content (segment, locale, device)\n- Essential query params that affect the result (but avoid noise)\n\nExamples:\n\n```ts\n// 1) Public, SWR with stable key\nexport const cache = \"stale-while-revalidate\";\nexport const cacheKey = (props: { slug: string }, req: Request) => {\n  const url = new URL(req.url);\n  url.search = new URLSearchParams([[\"slug\", props.slug]]).toString();\n  return url.href;\n};\n\n// 2) Segment-aware key; bypass for logged-in users\nexport const cache = \"stale-while-revalidate\";\nexport const cacheKey = (_props: unknown, _req: Request, ctx: AppContext) => {\n  if (!ctx.isAnonymous) return null; // don't cache personalized data\n  return ctx.segment?.token ?? \"anonymous\";\n};\n\n// 3) Custom TTL (5 minutes)\nexport const cache = { maxAge: 300 };\nexport const cacheKey = (props: { category: string }, req: Request) => {\n  const url = new URL(req.url);\n  url.search = new URLSearchParams([[\"category\", props.category]]).toString();\n  return url.href;\n};\n\n// 4) Explicitly opt-out (user-specific cart/session)\nexport const cache = \"no-store\";\n```\n\n## Best practices\n\n- Prefer \"stale-while-revalidate\" for public/read‑mostly loaders.\n- Always implement `cacheKey`; include props/params that affect data, and segmentation (locale/currency/segment) when relevant.\n- Return `null` from `cacheKey` for authenticated or highly personalized responses.\n- Set a custom TTL via `{ maxAge }` for data that tolerates longer staleness.\n- Avoid including volatile or irrelevant parameters (timestamps, tracking params) in the key.\n- If a loader must always execute but you still want the section cached, use `\"no-cache\"` instead of `\"no-store\"`.\n\n## Interaction with async rendering and CDN caches\n\n- Async rendering has a \"Stale Edge Cache\" that caches rendered sections at the CDN. This accelerates page delivery.\n- Loader caching reduces server latency and upstream API calls before the section render happens.\n- Use both: cache loaders for faster server responses, and keep async render defaults to leverage CDN caching of sections.\n\n## Environment and engines\n\n- `ENABLE_LOADER_CACHE` (default: true). Set to `\"false\"` to disable loader cache globally (not recommended).\n- `CACHE_MAX_AGE_S` (default: 60). Default TTL for string cache modes.\n- Advanced: `WEB_CACHE_ENGINE` can select cache backends (e.g., `CACHE_API`, `REDIS`, `FILE_SYSTEM`) or tiered configuration.\n\n## Real-world patterns\n\n- Build keys with only the inputs that matter (e.g., hash large arrays / objects).\n- Consider segment/locale in the key for internationalized or segmented catalogs.\n- For inventory/pricing that changes frequently, pick a lower TTL and rely on SWR to keep data fresh under load.\n\n## See also\n\n- [Optimizing loaders](https://deco.cx/docs/performance/loaders)\n- [Async render and Stale Edge Cache](https://deco.cx/docs/performance/edge-async-render)\n- [Loader concept](https://deco.cx/docs/en/concepts/loader)\n\n\n"
}