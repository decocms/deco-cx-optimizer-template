{
  "name": "19. Matcher Concept: Audience Segmentation Functions",
  "description": "Understanding Matchers as boolean-returning functions for creating Variants, Segments, and A/B tests with support for device, date, random, and custom conditions.",
  "content": "---\ndescription: A Matcher in deco.cx is a function that returns a boolean.\nsince: 1.18.0\n---\n\n## Matchers: Empowering Variants\n\n**Matchers** are essential building blocks in deco that play a pivotal role in\nempowering [Variants](https://deco.cx/docs/en/getting-started/variants). They allow you to\nevaluate specific conditions and segment your audience based on various\ncriteria. By leveraging Matchers, you can create personalized and dynamic\nexperiences for your users. When you create a new **Matcher Block** you may call\nit a [Segment](https://deco.cx/docs/en/concepts/segment).\n\n### Understanding Matchers\n\nIn deco, **Matchers** are created using _functions_ within your site's code.\nThey are powerful tools that enable you to define conditions and evaluate\nwhether a user belongs to a particular segment. **Matchers** serve as the\nfoundation for targeting specific user groups and personalizing content based on\ntheir characteristics or behaviors.\n\n_Standard Matchers_ are readily available in deco and cover a range of common\nconditions such as user traits, date and time, device type, geographic location,\nand random selection (A/B testing). These predefined Matchers offer\n_flexibility_ and allow you to customize content variations based on these\nconditions.\n\nHowever, the power of Matchers extends beyond the standard options. deco\nprovides the capability to create **custom Matchers** to meet the specific needs\nof your business. With custom Matchers, you can extend deco's functionality to\nintegrate external data sources, such as fetching data from a Salesforce ERP\nsystem, and then use that data to determine the segment to which a user belongs.\n\n### Native Matchers\n\n| Matcher        | Common Use Cases                                                                     | Sticky  |\n| -------------- | ------------------------------------------------------------------------------------ | ------- |\n| Random Matcher | A/B test your page with 50% of traffic.                                              | session |\n| Cron Matcher   | Change a page every Friday between 10 AM and 11 AM.                                  | none    |\n| Date Matcher   | Create a Black Friday page / Schedule banners to appear at specific dates and times. | none    |\n| Device Matcher | Show a different page based on the user's device.                                    | none    |\n\n### Developing a new Matcher\n\nIn your repository, matchers are located within the `matchers` folder, similar\nto sections and loaders. Let's create a new matcher called `MyMatcher.ts` to\nillustrate the process.\n\nThe signature of our matcher will follow this structure:\n\n```ts\nimport { MatchContext } from \"deco/blocks/matcher.ts\";\n\nexport interface Props {\n}\n\n/**\n * @title My Matcher\n */\nexport default function MyMatcher(\n  props: Props,\n  ctx: MatchContext,\n) {\n  return true;\n}\n```\n\nIn the example above, the `MyMatcher` function accepts `props` as the input,\nallowing you to pass any necessary data to the matcher. Additionally, it\nreceives a `ctx` object of type `MatchContext`, which contains the request\ninformation. You have the flexibility to perform any desired operations within\nthe matcher function and return a boolean value based on the evaluation.\n\nLet's take a look at the `MatchDate` example from the deco library:\n\n```ts\n/**\n * @titleBy start\n */\nexport interface Props {\n  /**\n   * @format date-time\n   */\n  start?: string;\n  /**\n   * @format date-time\n   */\n  end?: string;\n}\n\n/**\n * @title Date Matcher\n */\nconst MatchDate = (props: Props) => {\n  const now = new Date();\n  const start = props.start ? now > new Date(props.start) : true;\n  const end = props.end ? now < new Date(props.end) : true;\n  return start && end;\n};\n\nexport default MatchDate;\n```\n\nIn this example, the `MatchDate` function serves as a Matcher. It accepts\n`props` as input, which includes `start` and `end` properties. The function\nevaluates whether the current date falls within the specified date range. If no\n`start` or `end` value is provided, it defaults to `true`. The `MatchDate`\nfunction returns a boolean value based on the evaluation.\n\nMatchers can also have a \"sticky\" behavior, which is particularly useful for A/B\ntesting scenarios. To make a Matcher sticky on the user's session, you can\nexport a constant named `sticky` with the value `\"session\"`, as shown below:\n\n```ts\nexport const sticky = \"session\";\n```\n\nHere is an example of the `MatchRandom` implementation using the sticky session\nfeature:\n\n```ts\n/**\n * @title ABTest {{{percentage traffic}}}\n */\nexport interface Props {\n  traffic: number;\n}\n\n// Once selected, the session will reuse the same value\nexport const sticky = \"session\";\n\n/**\n * @title Random Matcher\n */\nconst MatchRandom = ({ traffic }: Props) => {\n  return Math.random() < traffic;\n};\n\nexport default MatchRandom;\n```\n\nIn the `MatchRandom` example, the matcher function `MatchRandom` accepts\n`traffic` as a prop, representing the percentage of traffic that should match\nthe condition. By generating a random number between 0 and 1, the function\ndetermines whether the generated value is less than the specified `traffic`\npercentage. The Matcher returns `true` or `false` based on this evaluation.\n\nMatchers provide great flexibility to customize and extend deco's functionality\nto meet your specific needs. With the ability to create custom Matchers, you can\nintegrate external data sources, perform complex calculations, and implement\nintricate logic to determine user segmentation and deliver personalized\nexperiences.\n\n### Harnessing the Power of Matchers in Variants\n\n**Matchers** form the backbone of Variants in deco. By _combining Matchers with\ndifferent conditions_, you can create targeted content variations for specific\nuser **segments**. **Variants** enable you to modify and personalize content\ndynamically based on the evaluation of **Matchers**.\n\nWhen configuring **Variants**, you can select the appropriate Matcher for each\nsegment and define the conditions that determine whether a user belongs to that\nsegment. By utilizing Matchers in Variants, you can fine-tune the user\nexperience, optimize content delivery, and deliver personalized interactions.\n"
}