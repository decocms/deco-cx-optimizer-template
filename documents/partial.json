{
  "name": "08. Partials: Server-Side Interactivity with HTMX",
  "description": "Advanced pattern for offloading frontend computation to edge servers using Fresh Partials and usePartialSection hook for SKU selectors, tabs, and dynamic UIs.",
  "content": "---\ndescription: Offload frontend computation to the server\nsince: 1.0.0\n---\n\nPartials empowers developers to optimize web interactions by offloading certain\ntasks from the user's device to Deco's Edge Servers. This innovative approach\nsignificantly reduces the amount of JavaScript required to run websites,\nresulting in faster page load times and improved conversion rates.\n\n## Introduction to Partials\n\nPartials, inspired by [htmx](https://htmx.org/docs/), operate by intercepting\nuser interactions on button, anchor, and form elements. These interactions are\nautomatically offloaded to our server, where they generate a new User Interface\n(UI) state. This fresh UI state is transmitted as pure HTML back to the user's\nbrowser. Our runtime seamlessly replaces and hydrates the new UI state, creating\nthe illusion of client-side interactivity. In reality, the entire computation\nprocess occurs in mere milliseconds on our Edge Servers. For more detailed\ninformation on Partials, please consult Fresh's\n[documentation](https://github.com/denoland/fresh/issues/1609).\n\n## Simplifying Development\n\nWhile Fresh Partials introduce a new realm of performance optimization, they\nalso bring added complexity to the development cycle. Developers now need to\nconsider multiple rendering modes, their impact on bundle and HTML sizes,\ninteraction latencies, and how to properly navigate partially rendered pages. To\nstreamline this process, Deco has integrated Partials into a higher abstraction\nlayer of our framework, eliminating the need for developers to grapple with\nthese complexities.\n\n## Leveraging Partials for Sections\n\nAt Deco, all [Sections](https://deco.cx/docs/en/concepts/section) are treated as partials. This\nmeans you can seamlessly incorporate client-side interactivity into any Section\nwithout compromising bundle sizes or initial page loads. This is particularly\nbeneficial for creating common UI components such as SKU selectors, infinite\nscroll features, and tabs. In the following sections, we'll delve into\nharnessing the full potential of Partials by creating a lightning-fast SKU\nselector.\n\n## Example: SKU Selector\n\nSKU selectors enable shoppers to explore different variations of a product, each\nwith its unique set of prices, images, and availability. Consider the example\nbelow:\n![sku-selector](https://github.com/deco-sites/starting/assets/1753396/cdaca2fc-34cd-404b-8679-d159872f7faa)\n\nAs demonstrated, altering the selected SKU can result in significant changes to\nthe page. A straightforward approach is to create a signal to store the\ncurrently selected SKU and update it on each click:\n\n```tsx\n// sections/ProductDetails.tsx\nexport default function ProductDetails ({ skus }) {\n  const selectedSku = useSignal(skus[0]);\n  \n  return (\n    <div>\n      <ImageSlider sku={selectedSku} />\n      <ProductPrice sku={selectedSku}>\n\n      Color:\n      <ul>\n        <li>\n          <button onClick={() => { selectedSku.value = skus[0] }}>Red</button>\n        </li>\n        <li>\n          <button onClick={() => { selectedSku.value = skus[1] }}>Blue</button>\n        </li>\n        <li>\n          <button onClick={() => { selectedSku.value = skus[2] }}>Green</button>\n        </li>\n      </ul>\n    </div>\n  )\n}\n```\n\nHowever, this implementation has a downside. To enable interactivity, the entire\nsection, including all SKU data and component code, is shipped to the browser,\nresulting in decreased site performance.\n\n> Note: If you only isolate the buttons as islands, selecting an SKU will not\n> update the displayed price or image, leading to an inconsistent UI.\n\nAn alternative approach is to transform the buttons into anchor tags, triggering\na new page load upon each SKU selection:\n\n```tsx\n// sections/ProductDetails.tsx\nexport default function ProductDetails ({ skus }) {\n  return (\n    <div>\n      <ImageSlider sku={selectedSku} />\n      <ProductPrice sku={selectedSku}>\n\n      Color:\n      <ul>\n        <li>\n          <a href={skus[0].url}>Red</a>\n        </li>\n        <li>\n          <a href={skus[1].url}>Blue</a>\n        </li>\n        <li>\n          <a href={skus[2].url}>Green</a>\n        </li>\n      </ul>\n    </div>\n  )\n}\n```\n\nWhile this approach offers optimal performance by eliminating the need for\nislands, it comes at the cost of user experience (UX). With every SKU selection,\nthe page reloads, and the user is taken back to the top of the page. To strike a\nbalance between UX and performance, let's refactor this component using\nPartials.\n\n### Enhancing UX and Performance with Partials\n\n```tsx\n// sections/ProductDetails.tsx\nimport { usePartialSection } from \"deco/hooks/usePartialSection.ts\";\n\nexport default function ProductDetails ({ skus }) {\n  return (\n    <div>\n      <ImageSlider sku={selectedSku} />\n      <ProductPrice sku={selectedSku}>\n\n      Color:\n      <ul>\n        <li>\n          <button {...usePartialSection({ href: skus[0].url })}>Red</button>\n        </li>\n        <li>\n          <button {...usePartialSection({ href: skus[1].url })}>Blue</button>\n        </li>\n        <li>\n          <button {...usePartialSection({ href: skus[2].url })}>Green</button>\n        </li>\n      </ul>\n    </div>\n  )\n}\n```\n\nThe magic here lies in the `usePartial` hook combined with the `button` tag.\nThis hook accepts an `href` parameter and enhances the button tag. When the user\nclicks the button, it triggers client-side navigation and applies HTML diff\nupdates. This approach eliminates the need for islands, boosting performance,\nwhile maintaining the scroll position for an improved user experience.\n\n## Example: Tabs\n\nWhile we've explored how to leverage Partials for SKU selectors, tabbed\nnavigation presents a unique challenge. Tabs lack canonical URLs, making it\nchallenging to manage state transitions. However, the `usePartialSection` hook\nallows us to override the props that a section uses for rendering, simplifying\nthe process:\n\n```tsx\nimport { usePartialSection } from \"deco/hooks/usePartialSection.ts\";\n\ninterface Props {\n  activeIndex: number;\n}\n\nconst TabbedSection = ({ activeIndex }) => {\n  return (\n    <div>\n      <button\n        class={activeIndex === 0 && \"active\"}\n        {...usePartialSection<typeof TabbedSection>({\n          props: { activeIndex: 0 },\n        })}\n      >\n        Tab 1\n      </button>\n      <button\n        class={activeIndex === 1 && \"active\"}\n        {...usePartialSection<typeof TabbedSection>({\n          props: { activeIndex: 1 },\n        })}\n      >\n        Tab 2\n      </button>\n      <button\n        class={activeIndex === 2 && \"active\"}\n        {...usePartialSection<typeof TabbedSection>({\n          props: { activeIndex: 2 },\n        })}\n      >\n        Tab 3\n      </button>\n    </div>\n  );\n};\n```\n\nIn this example, the `activeIndex` prop is overridden with each\n`usePartialSection` call, simplifying the use of Partials and eliminating the\nneed to manage URLs and search parameters within our sections.\n"
}